#  **Question1**
## 用你的语言描述图灵为什么要证明停机问题, 其证明方法和数学原理是什么.
###### &#160; &#160; &#160; &#160;答：图灵当时提出停机问题是想解决希尔伯特的可判定性问题，这个问题的原本形态是这样的：“能否找到一种普遍的算法，来判断一个丢番图方程是不是有解。”这个问题扩大化就变成了“是否存在一种通用算法，能够判断任何数学命题的真假”这就是希尔伯特的可判定性问题，图灵在此引入了一个假想的机器“图灵机”，将问题具象化为“对于任意给定的程序及输入，是否能判断其会不会停机。”只要证明了这个具象问题，那么希尔伯特可判定性问题就解决了。
###### &#160; &#160; &#160; &#160;对于这个复杂的问题，图灵采用了反证法：假定存在一个万能的算法A，给定一个任意的程序和输入，这个算法A能够判断是否能够停机；然后再存在另外一个程序B，如果对于给定的程序C，如果A判断它可以停机，那么B就永远循环下去（不能停机），如果A判断它不可以停机，那么B就停机；这时候我们再把程序B当做程序C输入程序B，就会发现，当A判断B可以停机的时候，B就永远循环不能停机，当A判断B不可以停机的时候，B就停机了。这就产生了矛盾，简单来讲，停机问题和”这句话是假的“这样的语言悖论是同一性质的，以自己为变量，对自己进行判断的自指结构。 
###### &#160; &#160; &#160; &#160;无论是希尔伯特的可判定问题还是图灵的停机问题，其背后的数学原理都是对角线方法。对角线方法的最简单应用就是证明实数集和自然数集不是一一对应的。证明如下：
###### &#160; &#160; &#160; &#160;_如果自然数和实数是一一对应的，那我们可以对实数一一标号，并且实数可以写成完整数加小数的形式。_
###### &#160; &#160; &#160; &#160;_(1) a10.a11a12a13……_
###### &#160; &#160; &#160; &#160;_(2) a20.a21a22a23……_
###### &#160; &#160; &#160; &#160;_(3) a30.a31a32a33……_
###### &#160; &#160; &#160; &#160;_(4) ……_
###### &#160; &#160; &#160; &#160;_这时候所有的实数都已经被编号好了，但是我们发现我们可以找到一个新的实数a，使得它的每一位小数（包括最开始的整数）不等于aii，这时候新的实数a不等于已经编好号的所有实数，这就证明了实数和自然数不是一一对应的。因为aii在列的数表里面成对角线排布，所以这个方法就叫做对角线方法._
###### &#160; &#160; &#160; &#160;那么对角线方法是怎么和图灵问题联系起来的呢？
###### &#160; &#160; &#160; &#160;_我们可以这样看图灵问题：我们将所有的图灵机编号A1，A2，A3……Aj，这些图灵机对不同的输入1，2，3，4……i，有不同的输出Aj(i)，我们假定如果停机，那么输出为1；如果不停机，那么输出为0。这时候根据对角线原理，我们肯定可以找到一个新的图灵机B它具有这样的性质：对于输入i，它的输出和Ai(i)不一样。那么这就是一个全新的图灵机，而之前我们已经假定所有的图灵机都已经在里面，所以必定有一个Am和B是相同的图灵机，然而对某一个相同的输入，它们得到了不同的输出，这就得到了矛盾。所以图灵停机问题的解决在本质上还是对角线原理。_
# **Qustion2**
## 你在向中学生做科普，请向他们解释二进制补码的原理.
###### &#160; &#160; &#160; &#160;答：二进制补码是这么定义的：在给定码长N的情况下，求一个负数-n的补码，就是找到一个实数n'，使得n+n'=2<sup>N</sup>。这句话是什么意思呢？我们想象一个环形的数表，比如日常生活中的时钟，把1-12排成一个圈，这样的话我们就可以定义把-1当作11来看，也就是顺时针走11步和逆时针走1步的效果是一样的，这就是二进制补码的基本原理。这时候我们把时钟上最大的数换成2<sup>N</sup>，那么同理，逆时针走n步和顺时针n'步是一样的，所以我们就可以把-n的数码用n'来表示。
# **Qustion3**
## 某基于 IEEE 754浮点数格式的 16 bit 浮点数表示, 有 8 个小数位, 请给出 ±0, ±1.0, 最大非规范化数, 最小非规范化数, 最小规范化浮点数, 最大规范化浮点数,±∞, NaN 的二进制表示(表示形式请参照讲义).
###### &#160; &#160; &#160; &#160;答：
|sign | exp |  frac| value |
| :-:| :-: |:-: | :-:|
|* |000 0000 | 0000 0000|±0| 
| * |011 1111  |0000 0000|±1.0 |
|  *|111 1111 |1111 1111 |±(2-2<sup>-8</sup>)×2<sup>64</sup>(最大非规范化数)|
| * | 000 0000| 0000 0001|±2<sup>-63</sup>×2<sup>-8</sup>(最小非规范化数)|
| * |000 0001 | 0000 0000|±2<sup>-62</sup>(最小规范化浮点数)|
| * |111 1110 | 1111 1111|±(2-2<sup>-8</sup>)×2<sup>63</sup>(最大规范化浮点数)|
| * |111 1111 |0000 0000 |±∞|
| * | 111 1111| non zero|NaN|
